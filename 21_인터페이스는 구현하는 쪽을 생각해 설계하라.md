## 21 인터페이스는 구현하는 쪽을 생각해 설계하라

디폴트 메소드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메소드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 이처럼 자바애도 기존 인터페이스에 메소드를 추가하는 길이 열렸지만 모든 기존 구현체들과 매끄럽게 연동되리라는 보장은 없다. 생각할 수 있는 모든 상황에서 불변식을 해치치 않는 디폴트 메소드를 작성하기란 어려운 법이다.

<br />

```java
// 자바 8의 Collection 인터페이스에 추가된 디폴트 메소드

default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    
    return result;
}
```

이 메소드는 현존하는 모든 `Collection` 구현체와 잘 어우러지지는 못한다. 대표적인 예가 아파치 커먼즈 라이브러리의 `SynchronizedCollection`이다. 이 클래스를 자바 8과 함께 사용한다면(그래서 `removeIf()`의 디폴트 구현을 물려받게 된다면), 자신이 한 약속을 더 이상 지키지 못하게 된다. 다시 말해 모든 메소드 호출을 알아서 동기화해 주지 못한다. `removeIf()`의 구현은 동기화에 관해 아무것도 모르므로 락 객체를 사용할 수 없다. 따라서 `SynchronizedCollection` 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 `removeIf()`를 호출하면 `ConcurrentModificationException`이 발생하거나 다른 예기치 못한 결과로 이어질 수 있다.

<br />

디폴트 메소드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다. 기존 인터페이스에 디폴트 메소드로 새 메소드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 한다. 추가하려는 디폴트 메소드가 기존 구현체들과 충돌하지는 않을지 심사숙고해야 함도 당연하다. 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메소드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해 준다.

<br />

한편, 디폴트 메소드는 인터페이스로부터 메소드를 제거하거나 기존 메소드의 시그니처를 수정하는 용도가 아님을 명심해야 한다. 이런 형태로 인터페이스를 변경하면 기존 클라이언트를 망가뜨리게 된다. 핵심은 명백하다. 디폴트 메소드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다. 디폴트 메소드로 기존 인터페이스에 새로운 메소드를 추가하면 커다란 위험도 딸려 온다.