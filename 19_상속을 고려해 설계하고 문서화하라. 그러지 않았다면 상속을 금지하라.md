## 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다. 클래스의 API로 공개된 메소드에서 클래스 자신의 또 다른 메소드를 호출할 수도 있다. 그런데 마침 호출되는 메소드가 재정의 가능 메소드라면 그 사실을 호출하는 메소드의 API 설명에 적시해야 한다. 덧붙여서 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다('재정의 가능'이란 `public`과 `protected` 메소드 중 `final`이 아닌 모든 메소드를 뜻한다). 더 넓게 말하면, 재정의 가능 메소드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다. 클래스를 안전하게 상속할 수 있도록 하려면 (상속만 아니었다면 기술하지 않았어야 할) 내부 구현 방식을 설명해야만 한다.

<br />

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 `훅(hook)`을 잘 선별하여 `protected` 메소드 형태로 공개해야 할 수도 있다.

<br />

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다. 꼭 필요한 `protected` 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다. 거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 `protected` 멤버는 사실 `private`이었어야 할 가능성이 크다. 널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과, `protected` 메소드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다. 이 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다. 그러니 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

<br />

상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안 된다. 이 규칙을 어기면 프로그램이 오동작할 것이다. 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 호출된다. 이때 그 재정의한 메소드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.

```java
public class Super {
    public Super() {
        // 잘못된 예 - 생성자가 재정의 가능 메소드를 호출한다.
        overrideMe();
    }
    
    public void overrideMe();
}


public final class Sub extends Super {
    // 초기화되지 않은 final 필드. 생성자에서 초기화한다.
    private final Instant instant;
    
    Sub() {
        instant = Instant.now();
    }
    
    // 재정의 가능 메소드. 상위 클래스의 생성자가 호출한다.
    @Override public void overrideMe() {
        System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

이 프로그램이 `instant`를 두 번 출력하리라 기대했겠지만, 첫 번째는 `null`을 출력한다. 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 `overrideMe()`를 호출하기 때문이다.

<br />

`Cloneable`과 `Serializable` 인터페이스는 상속용 설계의 어려움을 한층 더해준다. 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다. 그 클래스를 확장하려는 프로그래머에세 엄청난 부담을 지우기 때문이다.

`clone()`과 `readObject()` 메소드는 생성자와 비슷한 효과를 낸다(새로운 객체를 만든다). 따라서 상속용 클래스에서 `Cloneable`이나 `Serializable`을 구현할지 정해야 한다면, 이들을 구현할 때 따르는 제약도 생성자와 비슷하다는 점에 주의하자. 즉, `clone()`과 `readObject()` 모두 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안 된다. `readObject()`의 경우 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메소드부터 호출하게 된다. `clone()`의 경우 하위 클래스의 `clone()` 메소드가 복제본의 상태를 (올바른 상태로) 수정하기 전에 재정의한 메소드를 호출한다.

`Serializable`을 구현한 상속용 클래스가 `readResolve()`나 `writeReplace()` 메소드를 갖는다면 이 메소드들은 `private`이 아닌 `protected`로 선언해야 한다. `private`으로 선언한다면 하위 클래스에서 무시되기 때문이다. 이 역시 상속을 허용하기 위해 내부 구현을 클래스 API로 공개하는 예 중 하나다.

<br />

일반적인 구체 클래스는 `final`도 아니고 상속용으로 설계되거나 문서화되지도 않았다. 때문에 그대로 두면 위험하다. 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있기 때문이다. 이 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다. 클래스를 `final`로 선언하거나, 모든 생성자를 `private`이나 `package-private`으로 선언하고 `public` 정적 팩토리를 만들어 주는 방법이다.

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다. 이런 클래스라도 상속을 꼭 허용해야겠다면 합당한 방법이 하나 있다. 클래스 내부에서는 재정의 가능 메소드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것이다.



